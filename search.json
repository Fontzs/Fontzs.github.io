[{"title":"Git & Github","date":"2022-06-06T06:18:22.000Z","url":"/2022/06/06/Git%20&%20Github/","tags":[["Git","/tags/Git/"]],"categories":[["奇技淫巧","/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"]],"content":"命令行cd 打印当前的路径 dir 打印当前路径下的文件 cls 清楚命令 cd .. 返回上级目录 echo &lt;content&gt; &gt; &lt;fileName&gt;.&lt;fileType&gt; 创建文件 mkdir &lt;fileName&gt; 创建文件夹 rm &lt;file&gt; 删除文件 rmdir &lt;dir&gt; 删除文件夹 cd D: 切换到D磁盘 dir 现实当前目录所有文件夹 cd 相对路径/绝对路径 cd / 回到根目录 copy &lt;file&gt; &lt;path&gt; 将文件拷贝到path路径 move &lt;file&gt; &lt;path&gt; 将文件移动到path路径 git原理Working Directory .git(hidden): Staging Area (Index File), Commits (Objects Folder) git init 创建git repository git add &lt;file&gt; 添加文件 git rm &lt;file&gt; 删除文件 git commit -m &lt;message&gt; 提交文件 git status 查看状态 git add &lt;file&gt; 添加某一文件 git add . 添加所有文件 git log 查看日志 git ls-files 查看工作区文件 撤销commit: git reset --soft HEAD~&lt;number&gt; 撤销commit, 暂存区不变 git reset HEAD~&lt;number&gt; 撤销commit，暂存区变化 git reset --hard HEAD~&lt;number&gt; 撤销commit， 暂存区和工作区都变化 分支git branch 查看分支 git branch &lt;branchName&gt; 创建分支 git switch &lt;name&gt; &#x2F;git checkout &lt;branchName&gt; 切换分支 git switch -c &lt;name&gt; &#x2F; git checkout -b &lt;branchName&gt; 创建并切换分支 git merge &lt;name&gt; 合并某分支到当前分支 git branch -d &lt;branchName&gt; 删除分支 git log --graph 分支合并图 若使用git checkout &lt;id&gt;回退到，会形成一个分离的head分支，可在这个分离的分支上做修改。若切换git switch master，则head分支会消失。此时可以，再用git checkout &lt;branchName&gt; &lt;headId&gt;创建一个内容和分离分支相同的分支，再git merge &lt;branchName&gt;合并到主分支 fast-forward用于主分支未作提交,git merge &#96; git merge --squash &lt;branchName&gt; git merge --no-ff &lt;branchName&gt; git rebase 和 git merge的区别 git rebase 和 git merge 都是用来合并分支的 两者作用一样，但原理不同 假设有master和feature分支，在专用分支上开发新feature时，然后另一个团队在master分支提交了新的commits，若在master分支上的新提交与正在开发的feature相关，需要master分支将新提交的记录合并到feature分支，可以采用git merge或者git rebase 指令 git merge git merge会在feature分支新增一个新的merge commit，然后将两个分支的历史联系在一起 merge是一种非破坏性的操作，对现有分支不会以任何方式被更改 feature分支每次需要合并上游更改时，都会产生一个额外的合并提交 如果master提交非常活跃，可能会严重污染feature分支的历史记录，但可以用git log缓解 git rebase rebase会将整个feature分支移动到master分支的顶端，从而有效地整合了所有master分支上的提交 与merge提交方式不同，rebase通过为原始分支的每个提交创建全新的commits来重写项目历史记录，特点是仍然会在feature分支上形成线性提交 rebase的好处是可以获得清晰地项目历史，消除了git merge所需的不必要的合并提交，rebase还会产生完美线性的项目历史记录，可以在feature分支上没有任何分叉的情况下一直追寻到项目的初始提交 git merge 原理在对特征分支进行rebase后，等效于创建了新的提交，并且老的提交没有被销毁，但不能简单地被访问或使用 注意点： 在重放之前的提交的时候，git会创建新的提交，即使重放的提交与之前的一模一样，git仍然会视之为新的提交进行处理 git rebase并不会删除老的提交，也就是说对某个分支进行了rebase操作后，老的提交仍然存放在.git文件夹的objects目录下 如何取舍 get merge的优点是分支代码合并后不破坏原分支的代码提交记录，缺点是会产生额外的提交记录并进行两条分支的合并 git rebase优点是无须新增提交记录到目标分支，rebase后可以将对象分支的提交历史续上目标分支上，形成线性提交历史记录，进行review的时候更加直观 不能在一个共享的分支上进行Git rebase操作 回退修改HEAD指向的版本就是当前版本 查看修改内容: git diff &lt;file&gt; git reset . / git reset &lt;fike&gt; 撤销更改(已被add到暂存区) git checkout . / git checkout &lt;file&gt; 撤销更改(未被add到暂存区) git restore . / git restore &lt;file&gt; 撤销更改(未被add到暂存区) git stash / git stash -m &lt;message&gt; 撤销更改（未被add到暂存区） git stash apply 恢复更改 git stash list 查看更改列表 创建.gitignore, 可添加需要忽略的文件 例如 git clean -dn 打印添加的但未被跟踪的文件 git reflog 查看命令历史(30天) git reset --hard &lt;commit_id/HEAD~n&gt; 切换历史文件 查看文件: cat &lt;file&gt; 放弃工作区的修改: git checkout -- &lt;file&gt; 添加到暂存区，想放弃修改: git reset HEAD &lt;file&gt; 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 强行删除未合并过的分支: git branch -D &lt;name&gt; 查看远程库信息: git remote -v 从本地推送分支: git push origin &lt;branch-name&gt;,若推送失败先用git pull 抓取远程的新提交 在本地创建和远程分支对应的分支: git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt; 建立本地分支和远程分支的关联: git branch --set-upstream &lt;branch-name&gt; origin/&lt;branch-name&gt; 从远程抓取分支: &#96;git pull 远程仓库关联远程库: git remote add origin git@server-name:path/repo-name.git 第一次推送master分支: git push -u origin master 后续推送: git push origin master 克隆远程库: git clone &lt;link&gt; &#96; 标签管理新建标签: git tag &lt;tagname&gt;（默认为HEAD,可指定一个commit id） 指定标签信息: git tag -a &lt;tagname&gt; -m &quot;blabla……&quot; 查看所有标签: git tag 推送一个本地标签: git push origin &lt;tagname&gt; 推送所有未推送过的标签: git push origin --tags 删除一个本地标签: git tag -d &lt;tagname&gt; 删除一个远程标签: git push origin :refs/tags/&lt;tagname&gt; GitHublocal branch 与 remote branch之间通过 remote tracking branch（git branch -a进行查看）进行关联，本地与远程并没有直接联系 获取令牌setting - Developer settings - Personal tokens - Generate new token 本地推送到Github 在GitHub建立一个仓库 在本地建议一个与仓库名的文件夹，用vs code 打开，进行增删改查文件 在终端git init,再进行git add .或者git add &lt;filename&gt;,并且git commit -m &quot;blabla&quot; git remote add origin &lt;URL&gt; git branch -M main，分支重命名（可选） 若上步未重命名，则git push origin master ,否则git push -u origin main 如果git push无效，则git push origin master "},{"title":"Go并发编程","date":"2022-06-04T14:37:53.000Z","url":"/2022/06/04/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","tags":[["Go","/tags/Go/"],["并发","/tags/%E5%B9%B6%E5%8F%91/"]],"categories":[["Go","/categories/Go/"]],"content":"绪论主要困难： 不知道如何选择并发原语 在多个并发源于中选择最优解，比如mutex or chan？ 不知如何编排并发任务 排查panic或者死锁困难 已知的并发原语不能解决并发问题 核心内容基本并发原语：主要有Mutex RWMutex Waitgroup Cond Pool Context等标准库中的并发原语，这些都是传统的并发原语 原子操作：原子操作时其他并发原语的基础，可以以此创造新的并发原语 channel：chan类型时golang独有的，很好用 拓展并发原语：信号量、SingleFlight、循环栅栏、ErrGroup等 分布式并发原语: 是应对大规模的应用程序中并发问题的并发类型，主要有etcd实现的分布式并发原语，比如Leader选举、分布式互斥锁、分布式读写锁、分布式队列等 学习方向基础用法、实现原理、易错场景、知名项目bug 初始：任务编排用chan，共享资源保护用传统并发原语，进阶后不能局限于此 有野心地创造出自己需要地并发原语： 对既有并发原语进行组合，使用多个并发原语解决问题 根据已掌握地并发原语地设计经验，创造出合适地新的并发原语 解决资源并发访问问题互斥锁的实现机制互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。 临界区： 一个被共享的资源，为了避免并发访问导致的问题，部分程序需要被保护起来 使用互斥锁使临界区只能同时由一个线程持有 同步原语的使用场景： 共享资源 任务编排 消息传递 Mutex的基本使用方法sync包定义了一个Locker接口，Mutex就实现了这个接口 Locker 的接口定义了锁同步原语的方法集： 互斥锁mutex只提供两个方法:进入临界区之前调用Lock方法，退出临界区的时候调用Unlock方法 以这段代码为例子，若想实现10个goroutine 分别对count加10000，则目标结果为1000000 结果： 为什么结果是错的？rnm，退钱！！！ 因为count++不是一个原子操作，包含几个步骤，读取，加一，保存。若10个goroutine同时读取到并操作，最后只加了1，汇编代码如下 使用mutex的正确体位 mutex的其他用法嵌入到其它struct中使用 在初始化嵌入的struct时，不必初始化这个mutex字段 通过嵌入字段，直接在struct上调用Lock&#x2F;Unlock方法 还可以把获取锁、释放锁、计数加一的逻辑封装成一个方法 mutex实现mutex的架构演进分为四个阶段 初版：使用一个flag字段标识是否持有锁 给新人机会：新的goroutine也能有机会竞争锁 多给些机会：新来的和被唤醒的有更多的机会竞争锁 解决饥饿：解决竞争问题，不会让goroutine长久等待 初版的互斥锁通过一个flag变量，标记当前的锁是否被某个goroutine持有，如果flag的值是1，就代表锁已经被持有，那么，其他竞争的goroutine只能等待；如果这个flag的值是0，就可以通过CAS（compare-and-swap, 或者 compare-and-set)将这个flag设置为1，标识锁被当前goroutine持有了 Russ Cox在2008年提交的第一版mutex就是这样实现的 CAS指令将给定的值和一个内存地址中的值进行比较，如果是同一个值，就用新值替换内存地址中的值，这个操作是原子性的 字段key：是一个flag，用来标识这个排外锁是否被某个goroutine持有，如果key大于等于1，说明这个排外锁已经被持有 字段sema：是个信号量变量，用来控制等待goroutine的阻塞休眠和唤醒 调用Lock请求锁的时候，通过xadd方法进行CAS操作，xadd方法通过循环执行CAS操作直到成功，保证对key加1的操作成功完成。如果比较幸运，锁没有被别的goroutine持有，那么Lock方法成功地将key设置为1，这个goroutine就持有了这个锁；如果锁已经被别的goroutine持有了，那么，当前的goroutine会把key加1，而且会调用semacquire方法，使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒 持有锁的goroutine调用Unlock释放锁时，它会将key减1，如果当前没有其它等待这个锁的goroutine，这个方法就返回了。但是，如果还有等待此锁的其它goroutine，那么，它会调用semrelease方法，利用信号量唤醒等待锁对的其它goroutine中的一个。 在使用mutex的时候，必须要保证goroutine尽可能不去释放自己未持有的锁，一定要遵循“谁申请，谁释放”的原则，一般在同一个方法中获取和释放锁。 给新人机会2011年6月30日对mutex的调整 state字段是个复合字段，第一位（最小位）表示这个锁是否被持有，第二位代表是否有唤醒的goroutine，剩余的位数代表的是等待此锁的goroutine数 请求锁的方法Lock变得复杂，state操作难以理解，代码逻辑也变得复杂 "},{"title":"Golang中的奇技淫巧","date":"2022-04-25T07:22:54.000Z","url":"/2022/04/25/Golang%E4%B8%AD%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/","tags":[["Golang","/tags/Golang/"],["奇技淫巧","/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"]],"categories":[["Go","/categories/Go/"]],"content":"位运算 &amp; 运算在GO中， &amp; 运算符在两个整型操作数中执行按位 AND 操作， AND运算符具有选择性地把整形数据地位清除为0地好的效果。例如，我们可以使用&amp;运算符去清除（设置）最后4个最低有效位（LSB)全部为0 奇数的二进制数末尾为1，可以与1进行&amp;操作判断是否是奇数 | 操作符|对其整型操作数执行按位或操作 ^ 操作符在 Go 中 按位 异或 操作是用 ^ 来表示的。 异或运算符有如下的特点： 与 1 进行异或的位被翻转 可以利用 异或运算去比较两个数字的符号是否一样。当 (a ^ b) ≥ 0 （或相反符号的 (a ^ b) &lt; 0 ）为 true 的时候，两个整数 a，b 具有相同的符号 ^ 作为取反位运算符（非）XOR 运算符 ^，作为一元取反运算符作用于一个数字 &amp;^ 操作符&amp;^ 操作符意为 与非，是 与 和 非 操作符的简写形式 &lt;&lt; 和 &gt;&gt; 操作符Go 使用 &lt;&lt; 和 &gt;&gt; 来表示左移运算符和右移运算符 左移一位相当于除以2，右移一位相当于乘以2 "},{"title":"背包问题","date":"2022-04-14T11:43:03.000Z","url":"/2022/04/14/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[[" ",""]],"content":"01背包有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 二维数组动规五部曲: 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 确定递推公式 有两个方向推出来dp[i] [j]， 不放物品i：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。) 放物品i：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 所以递归公式： dp[i][j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); dp数组如何初始化 首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。 状态转移方程 dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。 dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。 那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。 当j &gt;&#x3D; weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。 dp[0] [j] 和 dp[i] [0] 都已经初始化了，那么其他下标应该初始化多少呢？ 其实从递归公式： dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出dp[i] [j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。 初始-1，初始-2，初始100，都可以！ 但只不过一开始就统一把dp数组统一初始为0，更方便一些。 确定遍历顺序 先遍历物品更好理解 先遍历背包，再遍历物品 举例遍历 一维滚动数组 完全背包有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。 完全背包和01背包的区别是，前者的物品是无限的，并且两者的遍历顺序是不同的 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序无强制规定 Java代码 Go代码 "},{"title":"两种古典密码：Hill和Affine密码 —— 基于Java实现","date":"2022-04-10T08:00:26.000Z","url":"/2022/04/10/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/","tags":[["密码学","/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"]],"categories":[["密码学","/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"]],"content":"Hill密码阶数增加到5会导致逆矩阵难以用整数精确表示，故姑且暂用3阶矩阵 若有原矩阵与逆矩阵皆为整数的矩阵对，亦可行 Affine密码in.nextInt()和in.nextLine()之间必须要有in.nextLine "},{"title":"SQL语言笔记","date":"2022-03-05T07:22:54.000Z","url":"/2022/03/05/SQL%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/","tags":[["SQL","/tags/SQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":"根据《SQL必知必会（第5版）》整理 ,由于不同的数据库管理系统对SQL标准略有不同，故撰文以汇之，此文以MySQL为标准，少量补充SQL Server（别问为什么，问就是因为考试考SQL Sever）。 数据库基础数据库（datebase）：保存有组织的数据的容器 数据库软件称为数据库管理系统（DBMS） 个人认为，数据库的结构可以这样认为：库 -&gt; 表 -&gt; 列（column）&#x2F; 行（row） -&gt; 项 通表同类型，同一数据库中表名是唯一的 行又称记录 主键为一张表的标识，由一列或者几列组成，每行都必须有一个主键值，每行的主键值都是唯一的 虽然SQL语言不区分大小写，但一般关键字都大写 检索数据多条SQL语句必须以“；”分隔，USE MySQL 语句中的USE表示使用某个库 SELECT语句SELECT选择列，例如 SELECT 可以选择多个列，各列之间用‘’，’‘分隔 检索所有列，用“*” 检索不同的值如果想去除查询结果中重复出现的记录，可以使用DISTINCT关键字，关键字必须在列名之前。DISTINCT关键字作用与所有列，不仅仅是跟在其后的列。 限定结果在MySQL 中想要限定结果数量，可以使用LIMIT关键字 SQL Server使用的是TOP 数据库中被检索的第一行是第0行，类似于数组的标号 注释 排序检索数据排序数据使用ORDER BY子句,这个子句是SELECT中最后的一条子句 按多个列排序 指定排序方式使用DESCEND关键字来降序 过滤数据使用WHERE子句ORDER BY位于WHERE之后 WHERE子句操作符BETWEEN在指定的两个值之间 IS NULL为NULL值 字符串用单引号（’ ‘）限定 范围值检查使用BETWEEN AND关键字 空值检查 高级数据过滤组合WHERE子句使用AND和OR AND 优先级高于OR IN操作符IN相当于OR NOT操作符在WHERE子句中用来否定其后条件的关键字 用通配符进行过滤LIKE操作符某词末尾加LIKE, 表示开头 加在首位表示含有 加在中间,%匹配0-n个字符 _通配符_匹配单个字符，用法与%类似"},{"title":"冲塔KMP算法","date":"2022-02-25T08:13:26.000Z","url":"/2022/02/25/%E5%86%B2%E5%A1%94KMP%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"不才，学完数据结构快一年了，但这一年里我一直被KMP算法困扰着。去年在课堂上时，关于这个算法我就听的云里雾里，在课后紧张的几分钟里，赶忙抓起教材,希望能够理解这一算法，匆忙翻阅几页，有种想撕书的冲动，暗暗克制住怒火。之后在网上，搜寻了许多资料，但一一读过后总有一种“词不达意”的感觉，遗憾没能深入理解这一算法。 最近在 LeetCode 上碰到了关于字符串的题目，恰巧需要用到KMP算法，于是借此机会重新梳理一下，同时相较于去年，我对这一算法的理解程度也加深了，希望以文章的形式促成我之思想与KMP 算法的完全融合吧。 KMP算法用武之地KMP算法主要是用于解决字符串匹配问题，若给出两个字符串m和n，需验证n是否是m的子字符串，此时KMP算法就派上用场了。 按照暴力解法，两个字符串分别有指针从头指到尾，一次进行比较，那么时间复杂度为O（m*n）,但使用KMP算法就不必从头指到尾进行比较了。 如上图的两串字符串，当上下指针到当前位置时，发生了不匹配的情况，按照暴力解法，上指针会移动到第二个字符，下指针会移动到首字符。而KMP算法的上指针不变，下指针会移动到b处。 前缀与前缀表前缀是指包含首字符，不含尾字符的子字符串。 后缀是指包含尾字符，不含首字符的子字符串。 前缀表记录的是以该字符为尾字符的字符串中前缀与后缀相等的最大长度。 next数组私以为next数组是KMP算法的核心，也是难点，所谓next数组就是前缀表。能否求出一串字符串的next数组是决定KMP算法实现与否的关键一步。 手撸next数组代码深入理解，有一种递归套娃的感觉，细思极恐！！！ 初始化指针 j = 0, i = 1 两指针所指字符进行比较，会有两种情况 两字符不匹配，此时，j需要回退,并且回退是一个连续的过程，一直回退到满足条件时才停止回退，一个条件是j已经不能再回退了，即j已经到达首字符处，另一个条件是**i和j所表示的字符相等。同时，需要注意回退并不是简单向前移位**而是根据前一个字符next值进行回退，这与文本串、模式串的比较过程有些类似。 两字符匹配，更新i出next值，i和j自增 "},{"title":"Java SE 笔记","date":"2022-02-09T20:07:53.000Z","url":"/2022/02/10/Java%20SE%20%E9%99%B7%E9%98%B1/","tags":[["Java","/tags/Java/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":" String 类型重新赋值会重新开辟空间创造新的应用，所以在参数绑定中无效 构造方法中可以调用其他构造方法，语法是 this(…) org.junit.Assert.assertArrayEquals(String[] a, String[] b);比较两个字符串数组是否相等 &quot;a&quot;.compareTo(&quot;b&quot;)比较两个字符串 子类**不会继承 **任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 可以在构造方法中初始化final字段 interface 继承interface用extends default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 interface的静态字段必须为final类型 Java不可直接只用泛型数组 string.substring(m, n) 左闭右开 Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable&lt;T&gt;这个接口 泛型的静态方法应该用另外的泛型类型 printStackTrace()方法可以打印异常栈 在catch中抛出异常，不会影响finally的执行，JVM会先执行finally，然后抛出异常 用@interface语法来定义注解 拼接多个字符串，其中有分隔符，可以用StringJoiner() int和Integer之间可以自动转换(自动装箱，自动拆箱) "},{"title":"图解系统笔记","date":"2022-02-09T20:07:53.000Z","url":"/2022/02/10/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/","tags":[["OS","/tags/OS/"],["操作系统","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"硬件结构图灵机的工作方式图灵机由纸带和读写头组成，纸带由一个个连续格子组成，每个格子可以写入字符，好比内存；读写头可以读取或者写入字符。 读写头部件：存储单元、控制单元、运算单元 存储单元存放数据 控制单元识别字符是数据还是指令，以及控制程序的流程 运算单元用于执行运算指令 "},{"title":"Java 数据结构","date":"2022-01-28T16:10:14.000Z","url":"/2022/01/29/Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":[["LeetCode","/tags/LeetCode/"],["Java语法","/tags/Java%E8%AF%AD%E6%B3%95/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"Java 数据结构​ 在CS界有一个著名的公式： 数据结构 + 算法 &#x3D; 程序设计,可见Data Structures和 Algorithm在CS中的重要地位了。虽然我曾经学习过数据结构，但非常遗憾的是，当初学习的数据结构是以C语言描述的，当时主要参考了两本书：一本是严蔚敏教授的数据结构(C语言版)，这本书的代码主要是以伪代码形式呈现，奈何本人水平太差，难以领会到算法的精妙思想；另一本书——数据结构教程,这本书所有代码都是用真实的C语言写的，作者自称这本书的所有代码都能够运行，与严教授的书相比，这本书内容要详细太多了，如果有充分的时间，我相信这本书可以是一本非常好的自学教材，但奈何学时和课业压力，至今尚未较为全面仔细地翻阅此书。 ​ 最近在学习CS 61B，学习这门课的主要目的是为了掌握一些基本的算法方便刷 LeetCode，次要的目的才是复习数据结构。这次的学习既可以说是复习，也可以说是学习新的知识，因为我并未掌握如何用Java语言描述基本的数据结构，因此才有了这篇文章。关于Java 我并不是十分精通，所以在学习Java数据结构的同时，我或许还会学到新的语法，是为序。 链表 LeetCode - 203.移除链表元素力扣链接给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点 。 示例 1： 示例 2： 示例 3： 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;&#x3D; Node.val &lt;&#x3D; 50 0 &lt;&#x3D; val &lt;&#x3D; 50 无虚拟节点 有虚拟节点 LeetCode - 707.设计链表力扣链接 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead (val)：在链表的第一个元素之前添加一个值为 val的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表最后一个元素。 addAtIndex(index, val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果index大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例： 提示： 所有val值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。 LeetCode - 206.反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 双指针法 递归 LeetCode - 24.两两交换链表中的节点给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： 示例 2： 示例 3： 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 二叉树Java语言描述二叉树 前序遍历递归方式 迭代方式 中序遍历递归方式 迭代方式 后序遍历递归方式 迭代方式 Red-black TreeThe red-black tree can be implemented with TreeMsp in Java or HashMAp in Java 8."},{"title":"LeetCode-59.螺旋矩阵-II","date":"2022-01-28T14:57:11.000Z","url":"/2022/01/28/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/","tags":[["LeetCode","/tags/LeetCode/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"59.螺旋矩阵 II题目Given a positive integer n, generate an n x n matrix filled with elements from 1 to n² in spiral order. Example 1: Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Example 2: Input: n = 1 Output: [[1]] Constraints: 1 &lt;= n &lt;= 20 题解这道题并没有考察算法，难点在于寻找螺旋数组生成的规律。 要寻找规律可以模拟生成过程走一遍 此图反映了螺旋数组生成的简单过程，这张图片有很明显的对称特点，而通过这一特点可以提取出生成规律： 若将循环一周作为一个周期，则每个二维数组有 n&#x2F;2 个周期 每个周期可以拆解为四个部分：从左到右，从上到下，从右到左，从下到上 建立x，y直角坐标系（右手系），新周期的起始位置的横纵坐标与上一周期结束位置的横纵坐标分别相差一 代码如下： "},{"title":"Markdown 基础语法","date":"2022-01-27T03:04:36.000Z","url":"/2022/01/27/Markdown-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","tags":[["Markdown","/tags/Markdown/"]],"categories":[["奇技淫巧","/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"]],"content":"Markdown 基础语法整理基础 斜体： * + 文字 + * 加粗： * * +文字+ * * 删除： ~~ +文字+~~ 多级标题 n个“#”+ space空格 对应n级标题 ctrl + n 对应n级标题 有序列表 数字+”.”+space空格 编号后一定要有空格 行末回车序号自动添加 行末↓键序号消失 删除&#x2F;添加某行内容，序号自动调整 降级快捷键 Tap 升级快捷键 Shift+Tap 例子： 打开冰箱 插电 开机 开门 把大象装入冰箱 关闭冰箱 无序列表 输入“*” 或者“-”后一定要加上空格 降级快捷键 Tap 升级快捷键 Shift+Tap 无序列表转换成有序列表 Ctrl+Shift+[ 有序列表和无序列表可以交错使用 任务列表 -+space空格+[+space空格+]+space空格 无快捷键，通过鼠标操作 选中文字-&gt;段落-&gt;任务列表 例子： 学习Java 学习计算机网络 学习Android 学习MySQL 分割线 三个以上*&#x2F;- 插入表格 文字|文字|文字-&gt;回车 添加一行 Ctrl + Enter 快捷键创建表格 Ctrl + T 行内代码 行内代码 反引号+代码+反引号 快捷键 Ctrl+Shift+&#96; 例子： Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征 代码块 三个&#96;&#x2F;三个~+代码 快捷键 Ctrl + Shift + K 元素类操作图片 快捷键 Ctrl+ Shift + I ! + [] + () 链接 方括号后紧接圆括号 Github 邮件 &lt; + 邮件地址 + &gt; "},{"title":"中国剩余定理","date":"2022-01-26T12:36:35.000Z","url":"/2022/01/26/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","tags":[["密码学","/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"],["初等数论","/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/"]],"categories":[["密码学","/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"]],"content":"验证中国剩余定理如题 三个方程组成的一次同余方程组 顺序是a1，a2，a3，m1，m2，m3 每个数字之间是通过换行来分割的 数字大小最大设值为500位 需要判断m值是否能运用一次同余方程。 题解"},{"title":"基于中国剩余定理的秘密共享方案","date":"2022-01-26T12:06:28.000Z","url":"/2022/01/26/%E5%9F%BA%E4%BA%8E%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E7%9A%84%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB%E6%96%B9%E6%A1%88/","tags":[["密码学","/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"],["初等数论","/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/"]],"categories":[["密码学","/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"]],"content":"基于中国剩余定理的秘密共享方案如题 题解"},{"title":"EIGamal公钥加密","date":"2022-01-23T20:07:53.000Z","url":"/2022/01/24/EIGamal%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/","tags":[["密码学","/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"],["初等数论","/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/"]],"categories":[["密码学","/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"]],"content":"EIGamal公钥加密算法如题 验收明文为150为以内接近150位的大整数 大素数p和本原根g自己生成 大素数选取形式为p&#x3D;2q+1形式的强素数，要求p为150位的大素数，q也是素数。强素数使得p-1只有四个因子：1，2，q，p-1，从而使本原元的判断变的简单，只需要验证2和q即可 中间数据显示，包括p,q,g,公私钥对，及密文c&#x3D;(c1, c2) 解密出的结果要与明文对比，验证解密是否正确 题解"},{"title":"张煌言","date":"2022-01-01T00:09:25.000Z","url":"/2022/01/01/%E5%BC%A0%E5%85%AC%E8%8B%8D%E6%B0%B4%E4%BC%A0/","tags":[["散文","/tags/%E6%95%A3%E6%96%87/"]],"categories":[["古文","/categories/%E5%8F%A4%E6%96%87/"]],"content":"此文文库 张公苍水传张煌言，字玄箸，浙江鄞县人。明崇祯十五年举人。时以兵事急，令兼试射，煌言三发皆中。慷慨好论兵事。顺治二年，师定江宁，煌言与里人钱肃乐、沈宸荃、冯元飏等合谋奉鲁王以海。煌言迎于天台，授行人。至绍兴，称“监国”，授翰林院修撰。入典制诰，出领军旅。三年，师溃。归与父母妻子决，从王次石浦，与黄斌卿军相犄角，加右佥都御史。 鲁王诸将，张名振最强。四年，江南提督吴胜兆请降，煌言劝名振援胜兆，遂监其军以行。至崇明，飓作，舟覆，煌言被执。七日，有导之出者，走间道复还入海。经黄岩，追者围而射之，以数骑突出，自是益习骑射。集义旅屯上虞、平冈。诸山寨多出劫掠，独煌言与?王翊履亩劝输，戢所部毋扰民。六年，觐王于健跳。七年，名振奉王居舟山，召煌言入。乃以平冈兵授刘翼明、陈天枢，率亲军赴之，加兵部侍郎。八年，闻父讣，浙江提督田雄书招降，却之。师攻滃洲，名振奉王侵吴淞，冀相牵制。俄，师破舟山，乃奉王入金门，依郑成功。成功用唐王隆武号，事鲁王但月上豚、米，修寓公之敬。煌言尝谓成功曰：“招讨始终为唐，真纯臣也！”成功亦曰：“侍郎始终为鲁，与吾岂异趋哉？”故与成功所事不同，而其交能固，王亦赖以安居。九年，监名振军，经舟山至崇明，进次金山。十年，复至崇明，师与战，败绩。十一年，又自吴淞入江，逼镇江，登金山，望祭明太祖陵。烽火达江宁，俄，退次崇明。再入江，略瓜洲、仪真，薄燕子矶，寻还屯临门，皆与名振俱。十二年，成功遣其将陈六御与名振取舟山，台州守将马信约降，煌言以沙船五百迎之。名振中毒卒，遗言以所部属煌言。 十三年，师再破舟山，煌言移军秦川，王去“监国”号，通表桂王。十四年，桂王使至，授煌言兵部侍郎、翰林院学士。两江总督郎廷佐书招煌言，煌言以书报，略曰：“来书揣摩利钝，指画兴衰，庸夫听之，或为变色，贞士则不然。所争者天经地义，所图者国恤家仇，所期待者豪杰事功。圣贤学问，故每毡雪自甘，胆薪深厉，而卒以成事。仆于将略原非所长，祗以读书知大义。左袒一呼，甲盾山立，济则赖君灵，不济则全臣节。凭陵风涛，纵横锋镝，今逾一纪矣，岂复以浮词曲说动其心哉？来书温慎，故报数行。若斩使焚书，适足见吾意之不广，亦所不为也。” 十五年，与成功会师将入江，次羊山，遇飓，引还。十六年，成功复大举，煌言与俱，次崇明。煌言曰：“崇明，江、海门户。宜先定营于此，庶进退有所据。”成功不从。师防江，金、焦两山间横铁索，隔江置大炮，煌言以十七舟翦江而渡。成功破瓜洲，欲取镇江，虑江宁援至，煌言曰：“舟师先捣观音门，南京自不暇出援。”成功以属煌言，煌言所将人不及万，舟不满百，即率以西。降仪真，进次六合，闻成功拔镇江，煌言致书，言当先抚定夹江郡县，以陆师趋南京，成功复不从。煌言进薄观音门，遣别将以轻舟数十直上攻芜湖，分兵掠江浦。成功水师至，会芜湖已降，趣煌言往抚，部勒诸军，分道略地，移檄诸郡县。于是太平、甯国、池州、徽州、广德及诸属县皆请降，得府四、州三、县二十四。煌言所过，秋毫无犯，经郡县，入谒孔子庙，坐明伦堂，进长吏，考察黜陟，略如巡按行部故事，远近回应。 方如徽州受降，闻成功败，还芜湖收兵，冀联合瓜洲、镇江军为守计，既，闻成功并弃瓜洲、镇江入海，煌言兵遂溃。南江总督郎廷佐发舟师断煌言东下道，书招煌言。煌言拒不应，率馀兵道繁昌，谋入鄱阳湖。次铜陵，师自湖广至，煌言与战而败，抚残兵仅数百，退次无为，焚舟登陆。自铜城道霍山、英山，度东溪岭，追骑至，从者尽散。煌言突围出，变服夜行，至高浒埠，有父老识之，匿于家数日，导使出间道，渡江走建德、祁门乱山间，痁作，力疾行，至休宁，得舟下严州。复山行，经东阳、义乌至天台达海，收集旧部，成功分兵益之，屯长亭乡，筑塘捍潮，辟田以赡军。使桂王告败，桂王敕慰问，加兵部尚书。十七年，移军临门。十八年，廷议徙海上居民绝接济，煌言无所得饷，开屯南田自给。 成功攻台湾，煌言移书阻之，不听。师下云南，取桂王。煌言遣其客罗纶入台湾，趣成功出兵，成功以台湾方定，不能行；遣使入郧阳山中，说十三家兵，使之扰湖广，以缓云南之师。十三家者，郝永忠、刘体纯辈，故李自成部将，窜据茅麓山，衰疲不敢出。康熙元年，煌言复移军沙堤。成功自攻江宁败还，取台湾谋建国。鲁王在金门，礼数日薄，煌言岁时供亿，又虑成功疑，十年不敢入谒。及闻桂王败亡，上启鲁王，将奉以号召。俄成功卒，煌言还军临门，又有议奉鲁王监国者，煌言使劝锦，以李亚子锦囊三矢相勖。 笼岛，煌言不可?浙江总督赵廷臣复招煌言，煌言书谢之。煌言孤军势日促，或议入。二年，鲁王殂，煌言恸曰：“孤臣栖栖海上，与部曲相依不去者，以吾主尚存也。今更何望？”三年，遂散遣其军，居悬澳。悬澳在海中，荒瘠无人?，南汊港通舟，北倚山，人不能上，煌言结茅而处，从者纶及部曲数人，一侍者、一舟子而已。廷臣与提督张杰谋致煌言，得煌言故部曲，使为僧普陀，伺煌言，知踪迹，夜半，引兵攀岭入，执煌言及纶，与部曲叶金、王发，侍者汤冠玉。煌言至杭州，廷臣宾礼之。九月乙未，死于弼教坊，举目望吴山，叹曰：“好山色！”赋绝命词，坐而受刃，纶等并死。煌言妻董、子万祺先被执，羁管杭州，先煌言死。"},{"title":"分类","date":"2022-06-30T02:37:56.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"标签","date":"2022-06-30T02:37:17.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"友情链接","date":"2022-06-30T02:38:50.000Z","url":"/link/index.html","categories":[[" ",""]]},{"title":"关于","date":"2022-08-05T02:11:21.000Z","url":"/about/index.html","categories":[[" ",""]],"content":" Github Email Instagram Twitter ​ #普不信男 #小镇做题家渣 #带专人 #蓝翔劝退生 Putty 本无树,MinGW 亦非台,误入歧途Cryptography 口舌代心，文章代口舌，作文以抒性灵。纵酒花间，解颐而已 ——回首向来萧瑟处，归去，也无风雨也无晴"},{"title":"友链","date":"2022-08-05T01:58:15.861Z","url":"/friends/index.html","categories":[[" ",""]]},{"title":"search","date":"2022-08-05T01:03:44.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"artitalk","date":"2022-08-05T01:57:49.000Z","url":"/artitalk/index.html","categories":[[" ",""]]}]